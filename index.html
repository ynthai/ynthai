<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Лабиринт на «Соколе Тысячелетия»</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            background: #34495E;
            border: 2px solid #2C3E50;
        }
        #winPopup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(44, 62, 80, 0.9);
            color: #F39C12;
            padding: 20px;
            border: 2px solid #2980B9;
            border-radius: 10px;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(41, 128, 185, 0.5);
        }
        #winPopup.hidden {
            display: none;
        }
        #winPopup button {
            background: #2ECC71;
            color: #FFF;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        #winPopup button:hover {
            background: #27AE60;
        }
    </style>
</head>
<body>
    <canvas id="mazeCanvas"></canvas>
    <div id="winPopup" class="hidden">
        <h1>Поздравляем!</h1>
        <p>Вы нашли выход из лабиринта.</p>
        <button onclick="resetGame()">Играть снова</button>
    </div>
    <script>
        const CELL_SIZE = 30; // Размер клетки в пикселях
        const canvas = document.getElementById("mazeCanvas");
        const ctx = canvas.getContext("2d");

        let maze, player;
        let playerPos = { x: 0, y: 0 }; // Позиция игрока для плавного движения
        let exitOpen = false; // Состояние двери
        let exitAnimationProgress = 0; // Прогресс анимации
        const winPopup = document.getElementById("winPopup");

        class Cell {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.walls = [true, true, true, true]; // Верх, право, низ, лево
                this.visited = false;
            }
        }

        class Maze {
            constructor(width, height) {
                this.width = width;
                this.height = height;
                this.grid = [];
                this.exitX = width - 1;
                this.exitY = height - 1;
                this.initializeGrid();
            }

            initializeGrid() {
                for (let x = 0; x < this.width; x++) {
                    this.grid[x] = [];
                    for (let y = 0; y < this.height; y++) {
                        this.grid[x][y] = new Cell(x, y);
                    }
                }
            }

            generateMaze(startX, startY) {
                const stack = [];
                const startCell = this.grid[startX][startY];
                startCell.visited = true;
                stack.push(startCell);

                while (stack.length > 0) {
                    const currentCell = stack.pop();
                    const neighbors = this.getUnvisitedNeighbors(currentCell);

                    if (neighbors.length > 0) {
                        stack.push(currentCell);
                        const randomNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
                        this.removeWall(currentCell, randomNeighbor);
                        randomNeighbor.visited = true;
                        stack.push(randomNeighbor);
                    }
                }
            }

            getUnvisitedNeighbors(cell) {
                const neighbors = [];
                const { x, y } = cell;

                if (y > 0 && !this.grid[x][y - 1].visited) neighbors.push(this.grid[x][y - 1]); // Верх
                if (x < this.width - 1 && !this.grid[x + 1][y].visited) neighbors.push(this.grid[x + 1][y]); // Право
                if (y < this.height - 1 && !this.grid[x][y + 1].visited) neighbors.push(this.grid[x][y + 1]); // Низ
                if (x > 0 && !this.grid[x - 1][y].visited) neighbors.push(this.grid[x - 1][y]); // Лево

                return neighbors;
            }

            removeWall(current, neighbor) {
                const dx = neighbor.x - current.x;
                const dy = neighbor.y - current.y;

                if (dx === 1) { // Сосед справа
                    current.walls[1] = false;
                    neighbor.walls[3] = false;
                } else if (dx === -1) { // Сосед слева
                    current.walls[3] = false;
                    neighbor.walls[1] = false;
                } else if (dy === 1) { // Сосед снизу
                    current.walls[2] = false;
                    neighbor.walls[0] = false;
                } else if (dy === -1) { // Сосед сверху
                    current.walls[0] = false;
                    neighbor.walls[2] = false;
                }
            }

            isExit(x, y) {
                return x === this.exitX && y === this.exitY;
            }
        }

        class Player {
            constructor(startX, startY) {
                this.x = startX;
                this.y = startY;
            }

            move(dx, dy) {
                const currentCell = maze.grid[this.x][this.y];
                if (dx === 1 && !currentCell.walls[1]) this.x++; // Вправо
                if (dx === -1 && !currentCell.walls[3]) this.x--; // Влево
                if (dy === 1 && !currentCell.walls[2]) this.y++; // Вниз
                if (dy === -1 && !currentCell.walls[0]) this.y--; // Вверх

                // Вибрация при ударе о стену
                if ((dx === 1 && currentCell.walls[1]) ||
                    (dx === -1 && currentCell.walls[3]) ||
                    (dy === 1 && currentCell.walls[2]) ||
                    (dy === -1 && currentCell.walls[0])) {
                    if ("vibrate" in navigator) navigator.vibrate(100); // Вибрация 100 мс
                }

                animatePlayer();
                checkWin();
            }
        }

        function drawMaze() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Отрисовка пола
            ctx.fillStyle = "#34495E";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Отрисовка стен и подсветки
            for (let x = 0; x < maze.width; x++) {
                for (let y = 0; y < maze.height; y++) {
                    const cell = maze.grid[x][y];
                    const startX = x * CELL_SIZE;
                    const startY = y * CELL_SIZE;

                    // Подсветка стен, если игрок рядом
                    const distance = Math.sqrt((player.x - x) ** 2 + (player.y - y) ** 2);
                    if (distance < 2) { // Если игрок в радиусе 2 клеток
                        ctx.strokeStyle = "#2980B9"; // Ярко-голубая подсветка
                        ctx.lineWidth = 4;
                    } else {
                        ctx.strokeStyle = "#2C3E50"; // Основной цвет стен
                        ctx.lineWidth = 2;
                    }

                    // Отрисовка стен
                    if (cell.walls[0]) ctx.strokeRect(startX, startY, CELL_SIZE, 0); // Верх
                    if (cell.walls[1]) ctx.strokeRect(startX + CELL_SIZE, startY, 0, CELL_SIZE); // Право
                    if (cell.walls[2]) ctx.strokeRect(startX, startY + CELL_SIZE, CELL_SIZE, 0); // Низ
                    if (cell.walls[3]) ctx.strokeRect(startX, startY, 0, CELL_SIZE); // Лево
                }
            }

            // Отрисовка игрока
            ctx.fillStyle = "#F39C12"; // Оранжевый цвет
            ctx.beginPath();
            ctx.arc(playerPos.x + CELL_SIZE / 2, playerPos.y + CELL_SIZE / 2, CELL_SIZE / 3, 0, Math.PI * 2);
            ctx.fill();

            // Отрисовка выхода
            drawExit();
        }

        function drawExit() {
            const exitX = maze.exitX * CELL_SIZE;
            const exitY = maze.exitY * CELL_SIZE;

            // Основа двери
            ctx.fillStyle = "#2C3E50"; // Темно-синий цвет
            ctx.fillRect(exitX + 5, exitY + 5, CELL_SIZE - 10, CELL_SIZE - 10);

            // Неоновая подсветка
            ctx.strokeStyle = "#2980B9"; // Голубой цвет
            ctx.lineWidth = 2;
            ctx.strokeRect(exitX + 5, exitY + 5, CELL_SIZE - 10, CELL_SIZE - 10);

            // Анимация открытия двери
            if (exitOpen) {
                ctx.fillStyle = "rgba(46, 204, 113, 0.5)"; // Полупрозрачный зеленый
                ctx.fillRect(
                    exitX + 5,
                    exitY + 5 + (CELL_SIZE - 10) * exitAnimationProgress,
                    CELL_SIZE - 10,
                    (CELL_SIZE - 10) * (1 - exitAnimationProgress)
                );
            }

            // Индикаторы
            ctx.fillStyle = "#2ECC71"; // Зеленый цвет
            ctx.beginPath();
            ctx.arc(exitX + CELL_SIZE / 2, exitY + CELL_SIZE / 2, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        function animatePlayer() {
            const targetX = player.x * CELL_SIZE;
            const targetY = player.y * CELL_SIZE;

            if (Math.abs(playerPos.x - targetX) > 0.1 || Math.abs(playerPos.y - targetY) > 0.1) {
                playerPos.x += (targetX - playerPos.x) * 0.2; // Плавное движение по X
                playerPos.y += (targetY - playerPos.y) * 0.2; // Плавное движение по Y
                drawMaze();
                requestAnimationFrame(animatePlayer);
            }
        }

        function animateExit() {
            if (exitOpen && exitAnimationProgress < 1) {
                exitAnimationProgress += 0.05; // Скорость анимации
                drawMaze();
                requestAnimationFrame(animateExit);
            }
        }

        function showWinPopup() {
            winPopup.classList.remove("hidden");
        }

        function resetGame() {
            winPopup.classList.add("hidden");
            maze.generateMaze(0, 0);
            player = new Player(0, 0);
            playerPos = { x: 0, y: 0 };
            exitOpen = false;
            exitAnimationProgress = 0;
            drawMaze();
        }

        function checkWin() {
            if (maze.isExit(player.x, player.y)) {
                exitOpen = true;
                animateExit();
                setTimeout(showWinPopup, 1000); // Показываем попап через 1 секунду
            }
        }

        function init() {
            const width = 10;
            const height = 10;
            canvas.width = width * CELL_SIZE;
            canvas.height = height * CELL_SIZE;

            maze = new Maze(width, height);
            maze.generateMaze(0, 0);

            player = new Player(0, 0);
            playerPos = { x: player.x * CELL_SIZE, y: player.y * CELL_SIZE };
            drawMaze();

            // Обработка нажатий клавиш
            window.addEventListener("keydown", (e) => {
                if (e.key === "ArrowUp" || e.key === "w") player.move(0, -1);
                if (e.key === "ArrowDown" || e.key === "s") player.move(0, 1);
                if (e.key === "ArrowLeft" || e.key === "a") player.move(-1, 0);
                if (e.key === "ArrowRight" || e.key === "d") player.move(1, 0);
            });
        }

        init();
    </script>
</body>
</html>